# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file is automatically generated by CrossSync. Do not edit manually.

from __future__ import annotations
from typing import Callable
from grpc import ChannelConnectivity
from grpc import Call
from grpc import Channel
from grpc import UnaryUnaryMultiCallable
from grpc import UnaryStreamMultiCallable
from grpc import StreamUnaryMultiCallable
from grpc import StreamStreamMultiCallable


class _WrappedMultiCallable:
    """
    Wrapper class that implements the grpc MultiCallable interface.
    Allows generic functions that return calls to pass checks for
    MultiCallable objects.
    """

    def __init__(self, call_factory: Callable[..., Call]):
        self._call_factory = call_factory

    def __call__(self, *args, **kwargs) -> Call:
        return self._call_factory(*args, **kwargs)


class WrappedUnaryUnaryMultiCallable(_WrappedMultiCallable, UnaryUnaryMultiCallable):
    def with_call(self, *args, **kwargs):
        call = self.__call__(self, *args, **kwargs)
        return (call(), call)

    def future(self, *args, **kwargs):
        raise NotImplementedError


class WrappedUnaryStreamMultiCallable(_WrappedMultiCallable, UnaryStreamMultiCallable):
    pass


class WrappedStreamUnaryMultiCallable(_WrappedMultiCallable, StreamUnaryMultiCallable):
    pass


class WrappedStreamStreamMultiCallable(
    _WrappedMultiCallable, StreamStreamMultiCallable
):
    pass


class _WrappedChannel(Channel):
    """
    A wrapper around a gRPC channel. All methods are passed
    through to the underlying channel.
    """

    def __init__(self, channel: Channel):
        self._channel = channel

    def unary_unary(self, *args, **kwargs) -> UnaryUnaryMultiCallable:
        return WrappedUnaryUnaryMultiCallable(
            lambda *call_args, **call_kwargs: self._channel.unary_unary(
                *args, **kwargs
            )(*call_args, **call_kwargs)
        )

    def unary_stream(self, *args, **kwargs) -> UnaryStreamMultiCallable:
        return WrappedUnaryStreamMultiCallable(
            lambda *call_args, **call_kwargs: self._channel.unary_stream(
                *args, **kwargs
            )(*call_args, **call_kwargs)
        )

    def stream_unary(self, *args, **kwargs) -> StreamUnaryMultiCallable:
        return WrappedStreamUnaryMultiCallable(
            lambda *call_args, **call_kwargs: self._channel.stream_unary(
                *args, **kwargs
            )(*call_args, **call_kwargs)
        )

    def stream_stream(self, *args, **kwargs) -> StreamStreamMultiCallable:
        return WrappedStreamStreamMultiCallable(
            lambda *call_args, **call_kwargs: self._channel.stream_stream(
                *args, **kwargs
            )(*call_args, **call_kwargs)
        )

    def channel_ready(self):
        return self._channel.channel_ready()

    def __enter__(self):
        self._channel.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        return self._channel.__exit__(exc_type, exc_val, exc_tb)

    def get_state(self, try_to_connect: bool = False) -> ChannelConnectivity:
        return self._channel.get_state(try_to_connect=try_to_connect)

    def wait_for_state_change(self, last_observed_state):
        return self._channel.wait_for_state_change(last_observed_state)

    def __getattr__(self, name):
        return getattr(self._channel, name)

    def close(self):
        return self._channel.close()

    def subscribe(self, callback, try_to_connect=False):
        return self._channel.subscribe(callback, try_to_connect)

    def unsubscribe(self, callback):
        return self._channel.unsubscribe(callback)


class _ReplaceableChannel(_WrappedChannel):
    def __init__(self, channel_fn: Callable[[], Channel]):
        self._channel_fn = channel_fn
        self._channel = channel_fn()

    def create_channel(self) -> Channel:
        new_channel = self._channel_fn()
        return new_channel

    def replace_wrapped_channel(self, new_channel: Channel) -> Channel:
        old_channel = self._channel
        self._channel = new_channel
        return old_channel
