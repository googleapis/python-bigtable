# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations
from typing import Sequence
import ast
from dataclasses import dataclass, field
"""
Entrypoint for initiating an async -> sync conversion using CrossSync

Finds all python files rooted in a given directory, and uses
transformers.CrossSyncClassDecoratorHandler to handle any CrossSync class
decorators found in the files.
"""


@dataclass
class CrossSyncOutputFile:
    """
    Represents an output file location.

    Multiple decorated async classes may point to the same output location for
    their generated sync code. This class holds all the information needed to
    write the output file to disk.
    """

    # The path to the output file
    file_path: str
    # The import headers to write to the top of the output file
    # will be populated when CrossSync.export_sync(include_file_imports=True)
    imports: list[ast.Import | ast.ImportFrom | ast.Try | ast.If] = field(
        default_factory=list
    )
    # The set of sync ast.ClassDef nodes to write to the output file
    converted_classes: list[ast.ClassDef] = field(default_factory=list)
    # the set of classes contained in the file. Used to prevent duplicates
    contained_classes: set[str] = field(default_factory=set)
    # the set of mypy error codes to ignore at the file level
    # configured using CrossSync.export_sync(mypy_ignore=["error_code"])
    mypy_ignore: list[str] = field(default_factory=list)

    def __hash__(self):
        return hash(self.file_path)

    def __repr__(self):
        return f"CrossSyncOutputFile({self.file_path}, classes={[c.name for c in self.converted_classes]})"

    def render(self, with_black=True, save_to_disk=False) -> str:
        """
        Render the output file as a string.

        Args:
            with_black: whether to run the output through black before returning
            save_to_disk: whether to write the output to the file path
        """
        full_str = (
            "# Copyright 2024 Google LLC\n"
            "#\n"
            '# Licensed under the Apache License, Version 2.0 (the "License");\n'
            "# you may not use this file except in compliance with the License.\n"
            "# You may obtain a copy of the License at\n"
            "#\n"
            "#     http://www.apache.org/licenses/LICENSE-2.0\n"
            "#\n"
            "# Unless required by applicable law or agreed to in writing, software\n"
            '# distributed under the License is distributed on an "AS IS" BASIS,\n'
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
            "# See the License for the specific language governing permissions and\n"
            "# limitations under the License.\n"
            "#\n"
            "# This file is automatically generated by CrossSync. Do not edit manually.\n"
        )
        if self.mypy_ignore:
            full_str += (
                f'\n# mypy: disable-error-code="{",".join(self.mypy_ignore)}"\n\n'
            )
        full_str += "\n".join([ast.unparse(node) for node in self.imports])  # type: ignore
        full_str += "\n\n"
        full_str += "\n".join([ast.unparse(node) for node in self.converted_classes])  # type: ignore
        if with_black:
            import black  # type: ignore
            import autoflake  # type: ignore

            full_str = black.format_str(
                autoflake.fix_code(full_str, remove_all_unused_imports=True),
                mode=black.FileMode(),
            )
        if save_to_disk:
            # create parent paths if needed
            import os
            os.makedirs(os.path.dirname(self.file_path), exist_ok=True)
            with open(self.file_path, "w") as f:
                f.write(full_str)
        return full_str


def convert_files_in_dir(directory: str) -> set[CrossSyncOutputFile]:
    import glob
    from transformers import CrossSyncClassDecoratorHandler

    # find all python files in the directory
    files = glob.glob(directory + "/**/*.py", recursive=True)
    # keep track of the output files pointed to by the annotated classes
    artifacts: set[CrossSyncOutputFile] = set()
    # run each file through ast transformation to find all annotated classes
    for file in files:
        converter = CrossSyncClassDecoratorHandler(file)
        new_outputs = converter.convert_file(artifacts)
        artifacts.update(new_outputs)
    # return set of output artifacts
    return artifacts

def save_artifacts(artifacts: Sequence[CrossSyncOutputFile]):
    for a in artifacts:
        a.render(save_to_disk=True)


if __name__ == "__main__":
    import sys

    search_root = sys.argv[1]
    outputs = convert_files_in_dir(search_root)
    print(f"Generated {len(outputs)} artifacts: {[a.file_path for a in outputs]}")
    save_artifacts(outputs)
